/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "5.0.2"
}

/**
*  Blink Camera Service Configuration Manager
*
* Copyright RBoy, redistribution of code is not allowed without permission
* 2016-4-34 - Debug message
* 2016-4-23 - Use display names instead of device names
* 2016-4-23 - Added support for live viewing of camera
* 2016-4-20 - Moved version to the top of the page
* 2016-4-19 - Fix for battery showing > 100%
* 2016-4-19 - Fixed version string
* 2016-4-16 - Added support to convert from F to C if required
* 2016-4-14 - Reset motion status when SM or Camera motion detection is turned off
* 2016-4-14 - Added support to configure video recording length
* 2016-4-12 - Performance optimization, don't need to query network ID each time, save it for future use since it doesn't change
* 2016-4-12 - Check for empty response
* 2016-4-12 - Reduced possibility of timeout when initializing app while refreshing all cameras
* 2016-4-7 - Updated checking endpoint codes for logged out clients, cleaned up logging in
* 2016-4-7 - Added cleanup of clients and URL registrations, logout unnecessary clients and only register the SmartApp logins with URL's (not device logins)
* 2016-4-5 - Added support for push notification from blink
* 2016-4-5 - Use homescreen endpoint instead of cameras endpoint to work around Blink server bug for rebooting cameras
* 2016-4-5 - Added support for multiple instance of Blink Camera Manager, one for each sync module (login)
* 2016-4-3 - Debug stuff
* 2016-4-2 - Debug messages to help find issues
* 2016-3-31 - Fix for ST platform state variable issue causing it lose track of last motion check resulting in previous motion events being reported as motion detection
* 2016-3-31 - Updated comment on switch interface to bring it more inline with Blink's definition
* 2016-3-30 - Fixed wrong version number reported
* 2016-3-29 - Fixed issue with  motion detection being reported when turning on camera if previous motion events were not processed
* 2016-3-29 - Improved UI layout
* 2016-3-22 - Added support to check for sync module going offline and reporting it to the user (don't send commands if sync module is offline)
* 2016-3-18 - Use the sync module to get information rather than polling each camera endpoint (Blink fixed endpoint), should improve performance significantly
* 2016-3-10 - Clarified description of options
* 2016-3-10 - Changed identifier string to reflect the ST client name and version number
* 2016-3-9 - Optimized and improved reliability of motion check timers and reduced server load
* 2016-3-8 - Fix for alternative detection of events from cameras (main sync module event broken till 3/19/16)
* 2016-3-8 - Added version information on top while configuring
* 2016-3-8 - Added support for integration with SHM
* 2016-3-7 - Added option to retry commands on failure (or turn it off)
* 2016-3-7 - Reusing auth token on the request to blink engineers to reduce server load
* 2016-3-7 - Optimize heartbeat system and schedule it on app install
* 2016-3-6 - Added heartbeat kickstart
* 2016-3-5 - Bugfix for scheduler backup kickstarter
* 2016-3-5 - Brand new scheduling system to make motion detection more reliable and resistant to the broken ST platform timer issues
* 2016-3-5 - Revamped the motion detection code to optimize calls to Blink server to reduce issues with the crappy ST platform timeout problem
* 2016-3-5 - Moved the refresh code on initialization to a referred run to avoid a timeout issue when many devices are configured
* 2016-3-4 - Fix for sending multiple commands to the server in a short period causing a conflict and command failure, queue and retry failed commands in 5 seconds
* 2016-3-4 - Added support to customize switch interface behavior to either control individual cameras or the entire system (sync module)
* 2016-3-3 - Clean up the code to stop execution additional commands if the camera is in conflict/busy to avoid throwing more errors
* 2016-3-3 - Dont' check for motion alerts if camera is disbaled
* 2016-3-2 - Bugfix for not being able to turn off intruder alerts
* 2016-3-2 - Kick start monitoring of events everytime camera is enabled just incast ST killed the timers
* 2016-3-2 - Poll period is a variable now and motion inactivity is linked to it
* 2016-3-2 - Default action is now to enable/disable camera. Motion must be enabled at global level for camera enable/disable to work
* 2016-3-1 - Added options to configure actions after a motion is detected
* 2016-3-1 - Added support for Motion Event notifications through Motion Sensor Interface
* 2016-2-29 - Added support for forcing camera sensors update and reporting last time they were updated
* 2016-2-27 - Added support for WiFi and LFR signal
* 2016-2-26 - Fixed issues with taking camera pictures and referred processing
* 2016-2-26 - Fixed battery reporting
* 2016-2-23 - Initial release
*
*/
definition(
    name: "Blink Camera Manager",
    namespace: "rboy",
    author: "RBoy",
    description: "Install, configure and manage your Blink cameras",
    category: "Safety & Security",
    iconUrl: "http://smartthings.rboyapps.com/images/Blink.jpg",
    iconX2Url: "http://smartthings.rboyapps.com/images/Blink.jpg",
    iconX3Url: "http://smartthings.rboyapps.com/images/Blink.jpg",
    singleInstance: false)

preferences {
    page(name: "mainPage")
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Blink Camera Manager v${clientVersion()}", install: true, uninstall: true) {
        // Let the user know the current status
        section("Blink Account Status") {
            if (blinkLogin && blinkPassword) {
                if (login()) {
                    def cameras = getBlinkCamerasList()
                    logout() // Logout so we clear the DB from hanging clients
                    if (cameras) {
                        cameras.each { camera ->
                            paragraph "Found Camera: $camera.name"
                        }
                    } else {
                        log.warn "No cameras found"
                        paragraph "No cameras found in account"
                    }
                } else {
                    log.error "Error getting account details"
                    paragraph "INVALID LOGIN: ERROR getting account details, check Login credentials or service is offline."
                }
            } else {
                log.warn "Invalid authentication credentials entered, Login: $blinkLogin, Password: $blinkPassword"
                paragraph "PLEASE ENTER BLINK ACCOUNT LOGIN DETAILS!"
            }
        }

        section("Blink Authentication") {
            input name: "blinkLogin", type: "text", title: "Login (eMail)", submitOnChange: true, required: true
            input name: "blinkPassword", type: "password", title: "Password", submitOnChange: true, required: true
        }

        section("Motion Detected Action Settings (optional)", hidden: ((sms || push || alarms || alarmSilent || lights || picture || cruisemap || resetPreset) ? false : true), hideable: true) {
            paragraph title: "Notifications", "You can enter multiple phone numbers to send an SMS to by separating them with a '+'. E.g. 5551234567+4447654321"
            input "sms", "phone", title: "Send SMS Notification to", required: false
            input "push", "bool", title: "Send Push Notification", required: false
            paragraph " "
            paragraph title: "External Alarms", "Select the external Alarm device to activate (sound and strobe) when motion is detected on the camera. When Silent Alarm is enabled, only the strobe light is activated."
            input "alarms", "capability.alarm", title: "Alarm to turn on if motion is detected", multiple: true, required: false
            input "alarmSilent", "bool", title: "Silent Alarm", required: false
            paragraph " "
            paragraph title: "Lights", "Select the lights or switches to activate when motion is detected on the camera"
            input "lights", "capability.switch", title: "Select lights/switches to turn on if motion is detected", multiple: true, required: false, submitOnChange:true
            if (lights) {
                input "lightTimer", "number", title: "Turn off lights/switches after (minutes)", description: "Leave empty to not turn off lights/switches", required: false
            }
            paragraph " "
            paragraph title: "Pictures", "Enable this option to have SmartThings take a picture when motion is detected on the camera"
            input "picture", "bool", title: "Take picture if motion is detected", required: false
        }

        section("Smart Home Monitor (SHM) Integration") {
            paragraph "Use these options to Enable/Disable Motion Detection for ALL Cameras when SHM changes modes"
            input "armAway", "bool", title: "Enable Motion Detection on Away", required: false
            input "armStay", "bool", title: "Enable Motion Detection on Stay", required: false
            input "disarmOff", "bool", title: "Disable Motion Detection on Off", required: false
        }

        section("Switch Interface Behavior (optional)") {
            paragraph "Each camera exposes itself as a Switch to ST which allows you to control the motion detection feature through SmartApps and Routines.\nThis option determines how it will behave when a Switch On/Off request is received.\nEnabling this option will Arm/Disarm the Blink system (sync module)\nDisabling it will Enable/Disable motion detection for the individual camera"
            input "switchControlsSystem", "bool", title: "Switch Interface Arms/Disarms System instead of Camera", required: false
        }

        section("Advanced Settings (optional)") {
            input "enableRetry", "bool", title: "Retry commands on server error", defaultValue: "true", required: false
            input "enablePollingEvents", "bool", title: "Poll Blink for motion events instead of using Push notifications (NOT recommended)", defaultValue: "false", required: false // DEBUGGING ONLY
        }

        section("Change Name of App (optional)") {
            label title: "Assign a name", required: false
        }
    }
}

def installed()
{
    log.debug "Installed: $settings"
    initialize()
}

def updated()
{
    log.debug "Updated: $settings"

    unsubscribe()
    unschedule()
    initialize()
}

def uninstalled() {
    log.trace "Uninstalled called"
    getChildDevices().each {device ->
        device.logout() // clear any pending clients from the blink servers by logging out of the child contexts
        log.info "Deleting Blink Camera Device $device.displayName"
        deleteChildDevice(device.deviceNetworkId)
    }
    
    logout() // clear any pending clients from this context
}

def initialize() {
    def cameras = []
    if (login()) { // Check if we have valid login credentials otherwise it goes into a loop
        cameras = getBlinkCamerasList()
        logout() // logout here since we won't use this token again (device will create it's token)
    } else {
        log.error "Invalid authentication credentials entered, Login: $blinkLogin, Password: $blinkPassword"
        sendNotification "Invalid Blink Login or Password entered" // Let the user know
    }

    // Create a device for each new camera in the blink account
    cameras.each { camera ->
        try {
            def existingDevice = getChildDevice(camera.id)
            if(!existingDevice) {
                log.info "Creating Blink Camera Device $camera.name"
                def childDevice = addChildDevice("rboy", "RBoy Blink Camera", camera.id, null, [name: "Blink $camera.name", label: "Blink $camera.name", completedSetup: true])
            } else {
                existingDevice.logout() // Logout of the context of existing client and start afresh with a new token for security
                log.trace "Blink Camera $existingDevice.displayName already exists"
            }

            atomicState."lastMotionCheck${camera.id}" = now() // Set the initial reference to check for motion events, use atomicState when using across child/parent interfaces since child cannot update state variables
            log.trace "Initializing last motion event checked at ${new Date(atomicState."lastMotionCheck${camera.id}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera $camera.name"
        } catch (e) {
            log.error "Error creating device: ${e}"
            sendNotification "Error creating Blink camera device"
            throw e // Don't lose the exception here
        }
    }

    // Delete devices for any cameras that are no longer in the blink account
    def delete = getChildDevices().findAll { device -> !cameras?.id.contains(device.deviceNetworkId) }
    delete.each {device ->
        log.info "Deleting Blink Camera Device $device.displayName as it no longer exists in the Blink account"
        try {
            deleteChildDevice(device.deviceNetworkId)
        } catch (e) {
            log.error e
            sendNotification "Device $device.displayName still in use. Remove from any SmartApps or Dashboards, then try again"
            throw e // Don't lose the exception here
        }
    }

    // Update the Switch interface behavior for the camera
    getChildDevices().each { device ->
        device.updateSwitchBehavior(switchControlsSystem)
    }

    atomicState.lastMotionMonitorCheck = 0 // use atomicState when using across child/parent interfaces since child cannot update state variables
    atomicState.lastHeartBeat = 0 // use atomicState when using across child/parent interfaces since child cannot update state variables
    atomicState.authToken = [] //We have no valid auth token now, reset it
    
    setupCallBackURL() // Initialize the ST access token to enable Blink event call backs, this is only done from SmartApp context and not device context (we need only 1 callback URL)

    // Subscribe to events to trigger kick start to compensate for broken ST timers
    if (enablePollingEvents) {
        subscribe(location, "sunrise", kickStart)
        subscribe(location, "sunset", kickStart)
        subscribe(location, "mode", kickStart)
        runEvery5Minutes(kickStart) // Start the heartBeat system
    }

    // SHM Integration
    subscribe(location, "alarmSystemStatus", shmHandler)

    runIn(1, refreshAll) // Refresh all devices status to get switch status and do it offline to avoid timing out
}

// Integration with SHM
def shmHandler(evt) {
    log.trace "SHM Handler called with state $evt.value"
    
    if (state.lastSHMState == evt.value) {
        log.trace "No change in SHM state, nothing to do"
        return // Nothing to do here, no change
    }

    switch (evt.value) {
        case "stay":
        	if (armStay) {
                log.trace "Enabling All Cameras Motion Detection on Stay"
                getChildDevices().each { device ->
                    enableAlerts(device)
                }
            } else {
                log.trace "No action configured for Stay"
            }
            break

        case "away":
        	if (armAway) {
                log.trace "Enabling All Cameras Motion Detection on Away"
                getChildDevices().each { device ->
                    enableAlerts(device)
                }
            } else {
                log.trace "No action configured for Away"
            }
            break

        case "off":
        	if (disarmOff) {
                log.trace "Disabling All Cameras Motion Detection on Away"
                getChildDevices().each { device ->
                    disableAlerts(device)
                }
            } else {
                log.trace "No action configured for Away"
            }
            break
            
        default:
            log.error "Invalid SHM state: $evt.value"
            break
    }

    state.lastSHMState = evt.value // Save it for next time on success
}

// Start the motion check monitoring
def startMonitor(async = false) {
    log.trace "Start Monitor Called, start polling for motion events. Synchronously: $sync"

    if (!enablePollingEvents) {
        log.warn "Polling not enabled, not polling for motion events"
        return
    }
    
    if (!async) { // Do it right now in the current context
        checkForMotionEvents()
    } else { // Do it offline asynchronously to avoid platform timeout
        runIn (1, checkForMotionEvents) // Do it asynchronously to avoid timeout issues with the crappy platform
    }
}

// Stop the motion check monitoring
def stopMonitor(evt) {
    log.trace "Stop Monitor Called, stop polling for motion events"

    if (!enablePollingEvents) {
        log.warn "Polling not enabled, not polling for motion events"
        return
    }
    
    unschedule()
}

// MOTION DETECTION AND HEARTBEAT MONITORING
// To work around the stupid broken ST platform timers setup multiple level of mechanisms to poll for motion detection (i.e. heartbeat monitor for motion detection) (thanks for @copy-ninja for the idea)
def kickStart(evt) {
    log.trace "Kick start called by $evt"

    if (!evt) {
        atomicState.lastHeartBeat = now() // Save the last time we scheduled motion event checks when not called by an event (i.e. heartbeat)
    }

    if (!enablePollingEvents) {
        log.warn "Polling not enabled, not polling for motion events"
        return
    }
    
    def monitorStatus = false
    def networkInfo = getNetworkInfo(null)
    if (networkInfo?.armed) {
        log.trace "Global Monitor Armed"
        monitorStatus = true
    } else {
        log.trace "Global Monitor DisArmed"
        monitorStatus = false
    }

    if (monitorStatus) { // If the monitoring is active
        // Reschedule the motion detection check if didn't update for more than 1 minutes beyond the polling period
        log.trace "Last motion detection check was done " + ((now() - (atomicState.lastMotionMonitorCheck ?: 0))/(60*1000)) + " minutes ago"
        if ((((atomicState.lastMotionMonitorCheck ?: 0) + (pollPeriod() * 1000) + (1*60*1000)) < now()) && canSchedule()) {
            log.warn "Motion detection hasn't been run a long time, rescheduling it for every ${pollPeriod()/60} minutes"
            schedule("* */" + (pollPeriod()/60) + " * * * ?", startMonitor) // Schedule the monitor check
            startMonitor(true) // It died, start the checking for motion events, do it offline/deferred
        }

        if (evt) { 
            log.trace "Scheduling a backup motion detection scheduler in 11 minutes" 
            runIn((5+6)*60, backupMotionDetectionScheduler) // Schedule a backup in 11 minutes (since the heartbeat runs every 5 minutes give it some grace)
            startMonitor() // Just incase it died, start the checking for motion events, driven by an external event then do it synchronously
        }
    }
}

// Backup scheduler (incase the original is overloaded)
def backupMotionDetectionScheduler() { 
    log.trace "Backup Motion Detection Scheduler"
    startMonitor() // Do it in the current context don't defer it
}

// Check every 60 seconds for new motion events (60 is the minimum resolution that can run reliably on the platform)
private pollPeriod() {
    return 1*60 // This should be multiple of 60 for now (due to limitations of schedule in kickStart() for now
}

// Time to turn off motion sensor (for push notifications)
private motionOffPeriod() {
    return 1*60 // Set to 1 minute to make it reliable or can change later
}

def checkForMotionEvents() {
    log.trace "Called check for new motion events"

    if (!enablePollingEvents) {
        log.warn "Polling not enabled, not polling for motion events"
        return
    }
    
    atomicState.lastMotionMonitorCheck = now() // Update the last time we checked for motion events

    // Hack for broken ST timers - Schedule the KickStart schedule check motion events
    if (((atomicState.lastHeartBeat ?: 0) + ((5+5)*60*1000) < now()) && canSchedule()) { // Since we are scheduling the heartbeat every 5 minutes, give it a 5 minute grace
        log.warn "Heartbeat not called in last 10 minutes, rescheduling heartbeat"
        runEvery5Minutes(kickStart) // run the motion detection scheduler every 5 minutes (heartbeat)
        atomicState.lastHeartBeat = now() // give it 5 minutes before you schedule it again
    }

    try {
        // Optimize by checking if any devices are active before reaching out to the network
        def allDevices = getChildDevices() // Get all cameras
        if (!allDevices.any { device -> ["on", "alarm"].contains(device.currentValue("enableStatus")) }) { // If the camera motion alerts is disabled don't check for motion alerts
            log.trace "All cameras are currently disabled, skipping motion check"
            return // nothing to check
        }

        def networkId = getNetworkID(null)
        if (!networkId) {
            log.error "Unable to get networkID"
            throw new RuntimeException("Unable to get networkID")  // lets try again later
        }

        def allEvents = []
        // Make this call just once, since it's per sync module and it's a very expensive operations and calling too many times can cause the shitty platform to timeout
        allEvents = getAllEventsForSyncModule(networkId, null)
        if (!allEvents) {
            log.error "Unable to get list of all events from sync module $networkId"
            throw new RuntimeException("Unable to get list of all events from sync module $networkId") // lets try again later
        }

        // Get check camera and check if we have events for them
        log.trace "Checking all cameras for motion events"
        allDevices.each {device ->
            checkCameraForMotionEvents(allEvents, networkId, device)
        }
    } catch (e) {
        log.error "Error while trying to check for camera motion events : $e"
    } // If there is a timeout execption catch it so that we can continue scheduling timers and don't let the system die due to a crappy ST platform
}
// END MOTION DETECTION AND HEARTBEAT

def motionDetectedTakeActions(child) {
    log.info "Motion detected in camera ${child.device.displayName}"

    // turn on the alarms
    log.debug "Turning on alarms $alarms, silent: $alarmSilent"
    alarmSilent ? alarms?.strobe() : alarms?.both()

    // turn on lights
    log.debug "Turning on lights $lights"
    lights?.on()
    if (lightTimer) {
        log.trace "Scheduling lights turn off after $lightTimer minutes"
        runIn(lightTimer * 60, turnOffLights)
    }

    // take picture
    if (picture) {
        log.debug "Taking a picture with camera ${child.device.displayName}"
        child.take()
    }

    // Send notifications
    log.debug "SMS: $sms, Push: $push"
    def message = "${child.device.displayName} has detected motion"
    sms ? sendText(sms, message) : ""
    push ? sendPush(message) : sendNotificationEvent(message)
}

def turnOffLights() {
    log.debug "Schedule called, turning off lights $lights"
    lights?.off()
}

private sendText(number, message) {
    if (sms) {
        def phones = sms.split("\\+")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}


// Blink REST Server
private serverURL() {
    return "http://prod.immedia-semi.com"
}

// Logout of Blink (to destroy client create by Blink at login)
private logout(child) {
	def success = false
    
    if (!atomicState.authToken) {
        log.warn "No active token found, not logging out of Blink"
        child?.log "No active token found, not logging out of Blink", "warn"
    	return true // nothing to logout do we're good
    }
    
    try {
        log.debug "Logging out of Blink using token: ${atomicState.authToken}"
        child?.log "Logging out of Blink using token: ${atomicState.authToken}", "debug"

        httpPost([
            uri: serverURL(),
            path: "/logout",
            headers: atomicState.authToken
        ]) { ret ->
            if (ret.data) {
                //log.trace "RESPONSE>" + ret.data
                //child?.log "RESPONSE>" + ret.data
                if (ret.data.message == "logout") { // Is there a error/warning message from the Blink server
                    log.trace "Blink server successfully logged out client"
                    child?.log "Blink server successfully logged out client"
                }
                success = true
            } else {
                log.error "No response to logout request: $ret.data"
                child?.log "No response to logout request: $ret.data", "error"
            }
        }
    } catch (e) {
        log.warn "Unable to logout, likely no active tokens: $e" // don't try to get status as it thorws an error
        child?.log "Unable to logout, likely no active tokens: $e", "warn"
    }

    atomicState.authToken = [] // We have no valid auth token now, reset it
    
    return success
}

// Login and return the Auth Token to use for calls
private login(child) {
    logout(child) // Logout before logging to clean up clients if they exist

    def authToken = null // Start with no authtoken since we have logged out
    def URL = enablePollingEvents ? "" : getCallBackURL(child) // Get callback URL to register with Blink when not using polling (only from SmartApp context, device context should be empty because there should be no accesstoken)
    
    try {
        log.trace "Performing login and getting authentication token"
        child?.log "Performing login and getting authentication token"
        httpPost(
            [
                uri: serverURL(),
                path: "/login",
                body: [
                    email: blinkLogin,
                    password: blinkPassword,
                    client_specifier: "SmartThings Client | ${clientVersion()}",
                    client_type: "smartthings",
                    notification_key: URL
                ]
            ]
        ) { ret ->
            if (ret.data?.authtoken?.authtoken) {
                authToken = ret.data.authtoken.authtoken
                //log.trace "Received authentication token: $authToken"
                //child?.log "Received authentication token: $authToken"
            } else {
                log.error "Login failed, response: $ret.data"
                child?.log "Login failed, response: $ret.data", "error"
                authToken = null
            }
        }
    } catch (e) {
        log.error "Exception during login: $e" // don't try to get status as it thorws an error
        child?.log "Exception during login: $e", "error"
        authToken = null
    }

    if (authToken) {
        atomicState.authToken = [ TOKEN_AUTH: authToken ] // Save it for use until it expires
        cleanUpSTClients(child) // Get rid of inactive clients so we don't need unnecessary notifications (only if we have authenticated)
    } else {
        atomicState.authToken = [] // We don't have a token
    }
    
    
    log.debug "Got new AuthToken = $atomicState.authToken"
    child?.log "Got new AuthToken = $atomicState.authToken", "debug"
    
    return atomicState.authToken
}

// Query Blink Account
private queryBlink(path, child = null) {
    def response = null
    try {
        log.trace "Querying Blink: $path"
        child?.log "Querying Blink: $path"
        //log.warn "Saved Auth Token: $atomicState.authToken" // DEBUG
        //child?.log "Saved Auth Token: $atomicState.authToken", "warn" // DEBUG
        httpGet([
            uri: serverURL(),
            path: path,
            headers: atomicState.authToken ?: login(child)
        ]) { ret ->
            /*log.trace "Received response from camera to httpGet, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            child?.log "Received response from camera to httpGet, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            if (ret.status == 200) {
                //log.trace "RESPONSE>" + ret.headers.'Content-Type'
                child?.log "RESPONSE>" + ret.headers.'Content-Type'
                if(ret.headers.'Content-Type'.contains("image/jpeg")) { // If we have a picture store it directly
                    //log.trace "Got JPEG IMAGE"
                    child?.log "Got JPEG IMAGE"
                }
            }*/

            if (ret.data) {
                //log.trace "RESPONSE>" + ret.data
                //child?.log "RESPONSE>" + ret.data
                response = ret.data
            } else {
                log.error "No response to query: $ret.data"
                child?.log "No response to query: $ret.data", "error"
            }
        }
    } catch (e) {
        log.error "Exception while querying: $e with status $e.response.status"
        child?.log "Exception while querying: $e with status $e.response.status", "error"
        if ((e.response.status == 401) && (e.response.data?.message == "Unauthorized Access")) { // Check if the token has expired or invalid
            try {
                log.warn "Authentication token has expired, logging in again and getting new authentication token"
                child?.log "Authentication token has expired, logging in again and getting new authentication token", "warn"
                login(child)
                return queryBlink(path, child) // Lets try it again
            } catch (f) {
                log.error "Exception while getting new authentication token: $f"
                child?.log "Exception while getting new authentication token: $f", "error"
            }
        }
    }

    return response
}

// Send Command to Blink Account
private configureBlink(path, child = null, params = []) {
    def response = null
    try {
        log.trace "Configuring Blink: $path${params ? " with params $params" : ""}"
        child?.log "Configuring Blink: $path${params ? " with params $params" : ""}"
        //log.warn "Saved Auth Token: $atomicState.authToken" // DEBUG
        //child?.log "Saved Auth Token: $atomicState.authToken", "warn" // DEBUG
        httpPost([
            uri: serverURL(),
            path: path,
            headers: atomicState.authToken ?: login(child),
            body: params
        ]) { ret ->
            if (ret.data) {
                //log.trace "RESPONSE>" + ret.data
                //child?.log "RESPONSE>" + ret.data
                if (ret.data.message) { // Is there a error/warning message from the Blink server
                    log.warn "Blink server response to configuration request: $ret.data.message"
                    child?.log "Blink server response to configuration request: $ret.data.message", "warn"
                }
                response = ret.data
            } else {
                log.error "No response to configuration request: $ret.data"
                child?.log "No response to configuration request: $ret.data", "error"
            }
        }
    } catch (e) {
        log.error "Exception while configuring: $e with status $e.response.status"
        child?.log "Exception while configuring: $e with status $e.response.status", "error"
        if ((e.response.status == 401) && (e.response.data?.message == "Unauthorized Access")) {
            try {
                log.warn "Authentication token has expired, logging in again and getting new authentication token"
                child?.log "Authentication token has expired, logging in again and getting new authentication token", "warn"
                login(child)
                return configureBlink(path, child) // Lets try it again
            } catch (f) {
                log.error "Exception while getting new authentication token: $f"
                child?.log "Exception while getting new authentication token: $f", "error"
            }
        }
    }

    return response
}

private cleanUpSTClients(child) {
    return // TODO: implement cleaning of clients (check for clients with URL and expired token/old create dates and not udpated
    
    log.trace "Cleaning up expired SmartThings clients"
    child?.log "Cleaning up expired SmartThings clients"

    def stClients = getActiveSTClients(child)
    if (!stClients) {
        log.warn "No ST clients found"
        child?.log "No ST clients found", "warn"
        return
    }
}

// Get the list of registered SmartThings clients
private getActiveSTClients(child) {
    log.trace "Getting list of active SmartThings clients"
    child?.log "Getting list of active SmartThings clients"

    def stClients = []
    try {
        def info = queryBlink("/account/clients", child)
        //log.trace "Active ST Clients raw: $info"
        //child?.log "Active ST Clients raw: $info"
        stClients = info?.clients?.findAll { client -> client.client_specifier.contains("SmartThings") } // Isolate the ST clients only
        //log.trace "Active ST Clients found: $stClients"
        //child?.log "Active ST Clients found: $stClients"
        def stClientsURL = stClients?.findAll { client -> client.notification_key }
        log.warn "Total Active ST Clients found: ${stClients?.size()}, with URL: ${stClientsURL?.size()}"
        child?.log "Total Active ST Clients found: ${stClients?.size()}, with URL: ${stClientsURL?.size()}", "warn"
        def urlClientDetails = stClientsURL?.collect { client ->
            "Active ST URL Clients, Created: ${Date.parse("yyyy-MM-dd'T'HH:mm:ssXXX", client.created_at).format("EEE MMM dd yyyy HH:mm z", location.timeZone)}, Updated: ${Date.parse("yyyy-MM-dd'T'HH:mm:ssXXX", client.updated_at).format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"
        }?.join("\n")
        log.warn "${urlClientDetails}"
        child?.log "${urlClientDetails}", "warn"
    } catch (e) {
        log.error "Unable to get ST clients: $e", "error"
        child?.log "Unable to get ST clients: $e", "error"
    }

    return stClients
}

// Check if the command has been successfully completed
private getCommandStatus(networkId, commandId, child) {
    child?.log "Getting state of command: $commandId"

    if (!commandId) {
        child?.log "Not querying command status, invalid command id: $commandId", "warn"
        return false
    }

    def completed = false
    def info = queryBlink("/network/$networkId/command/$commandId", child)
    //child?.log info
    try {
        if (info.status_msg == "Command succeeded") {
            completed = true
        }
        child?.log "Command result: $info.status_msg"
    } catch (e) {
        child?.log "Unable to get command status: $e", "error"
        completed = false
    }

    return completed
}

// Get the first sync module network ID
private getNetworkID(child) {
    child?.log "Getting first Sync Module network ID"

    def networkId = child ? child.getNetworkId() : atomicState.networkId
    if (!networkId) {
        try {
            def info = queryBlink("/networks", child)
            networkId = info.networks[0].id
            
            // Cache it for future (performance improvement, each call to Blink is 2-3 seconds) and this is the most used call
            if (child) {
                child.saveNetworkId(networkId) // Child call, save to child
            } else {
                atomicState.networkId = networkId // Local app, save it locally
            }
            
            child?.log "First sync module NetworkID: $networkId"
        } catch (e) {
            child?.log "Unable to get network id: $e", "error"
        }
    } else {
        child?.log "Saved sync module NetworkID: $networkId"
    }

    return networkId
}

// Check if the sync module is online and if so return sync module network ID
private isSyncModuleOnlineGetID(child) {
    child?.log "Getting first Sync Module network ID"

    def networkId = null
    try {
        def info = queryBlink("/networks", child)
        if (info.networks[0].sync_module_error) {
	        child?.log "First SYNC MODULE IS OFFLINE!", "warn"
            
            // Let the device handler know so it can update the tiles
            def events = []
            events << [name:"monitorStatus", value: "offline", displayed: true] // Show it on the logs
            child.generateEvent(events) // Update the device status
        } else {
            networkId = info.networks[0].id
            child?.log "First sync module NetworkID: $networkId"
        }
    } catch (e) {
        child?.log "Unable to get network id: $e", "error"
    }

    return networkId
}

// Get the homescreen devices and information
private getBlinkHomescreenDevices(child) {
    child.log "Getting Homescreen devices"

    def info = queryBlink("/homescreen", child)

    child.log "Found devices ${info?.devices}"
    
    return info?.devices
}

// Return map with camera 'name' and 'id'
private getBlinkCamerasList(child) {
    log.trace "Getting Cameras List"
    child?.log "Getting Cameras List"

    def cameras = []
    def info = queryBlink("/homescreen", child)
    info?.devices.each { device ->
        if (device.device_type == "camera") {
            log.trace "Found Camera $device.name with Id $device.device_id"
            child?.log "Found Camera $device.name with Id $device.device_id"
            cameras << [name: device.name, id: device.device_id as String] // Save just the camera name and id
        }
    }

    //log.trace cameras
    //child?.log cameras
    return cameras
}

// Return map with all cameras summary (camera id is stored under device_id)
private getAllCamerasSummary(child) {
    log.trace "Getting Cameras Summary"
    child?.log "Getting Cameras Summary"

    def cameras = []
    def info = queryBlink("/homescreen", child)
    info?.devices.each { device ->
        if (device.device_type == "camera") {
            log.trace "Found Camera $device.name with Id $device.device_id"
            child?.log "Found Camera $device.name with Id $device.device_id"
            cameras << device // Add it to the list
        }
    }

    //log.trace cameras
    //child?.log cameras
    return cameras
}

// Get all cameras detailed information
private getAllCamerasDetails(networkId, child) {
    child?.log "Getting All Cameras Details"

    def cameras = queryBlink("/network/$networkId/cameras", child)
    //child?.log cameras

    if (!cameras?.devicestatus) {
        child?.log "Error: Blink returned:$cameras", "error"
    }
    
    return cameras?.devicestatus
}

// Get specific camera information
private getCameraDetails(networkId, cameraId, child) {
    child?.log "Getting Camera $cameraId Details"

    def camera = queryBlink("/network/$networkId/camera/$cameraId", child)
    //child?.log camera.camera_status.inspect()

    if (!camera?.camera_status) {
        child?.log "Error: Blink returned:$camera", "error"
    }
    
    return camera?.camera_status
}

// Get specific camera configuration
private getCameraConfig(networkId, cameraId, child) {
    child?.log "Getting Camera $cameraId Configuration"

    def camera = queryBlink("/network/$networkId/camera/$cameraId/config", child)
    //child?.log camera.camera[0].inspect().substring(0,2000) // Doesn't fit in one line so split it
    //child?.log camera.camera[0].inspect().substring(2000)

    if (!camera?.camera[0]) {
        child?.log "Error: Blink returned:$camera", "error"
    }
    
    return camera?.camera[0]
}

// Get specific camera signals information
private getCameraSignalDetails(networkId, cameraId, child) {
    child?.log "Getting Camera $cameraId Signal Details"

    def signal = queryBlink("/network/$networkId/camera/$cameraId/signals", child)
    //child?.log signal.inspect()

    return signal
}

// Get details of all videos taken from the camera currently on the cloud
private getCameraVideoDetails(networkId, cameraId, child) {
    child?.log "Getting All Videos Details for Camera ID $cameraId"

    def videos = queryBlink("/network/$networkId/camera/$cameraId/videos/unwatched", child)

    if (!videos?.video) {
        child?.log "Error: Blink returned:$videos", "error"
    }
    
    return videos?.video
}

// Get the first sync module network details
private getNetworkInfo(child) {
    child?.log "Getting first Sync module Network Info"

    def networkInfo = null
    def info = queryBlink("/networks", child)
    networkInfo = info?.networks[0]

    //child?.log "NETWORK INFO>" + networkInfo
    return networkInfo
}

// Get all the events for a sync module and all it's connected cameras
private getAllEventsForSyncModule(networkId, child) {
    child?.log "Getting All Events for Sync Module $networkId"
    log.trace "Getting All Events for Sync Module $networkId"

    // NOTE: This is a very heavy time consuming call
    //def events = queryBlink("/events", child) // Returns the last 200 events from the camera
    def events = queryBlink("/events/network/$networkId", child) // Returns the last 100 events from the camera
    //child?.log "All Events retrieved:\n${events.event.inspect()}"
    //log.trace "All Events retrieved:\n${events.event.inspect()}"

    if (!events?.event) {
        child?.log "Error: Blink returned:$events", "error"
        log.error "Error: Blink returned:$events"
    }
    
    return events?.event
}

// Get all the events for a camera
private getAllEventsForCamera(networkId, cameraId, child) {
    child?.log "Getting All Events for camera $cameraId"
    log.trace "Getting All Events for camera $cameraId"

    // NOTE: This is a very heavy time consuming call
    def events = queryBlink("/events/network/$networkId/camera/$cameraId", child) // Returns the last 100 events from the camera
    //child?.log "All Camera Events retrieved:\n${events.event.inspect()}"
    //log.trace "All Camera Events retrieved:\n${events.event.inspect()}"

    if (!events?.event) {
        child?.log "Error: Blink returned:$events", "error"
        log.error "Error: Blink returned:$events"
    }
    
    return events?.event
}


// UPDATE STATUS METHODS
// Get and update Image of camera
def Boolean updateCameraImage(child) {
    child?.log "Getting Camera Image for ${child?.device.displayName}"

    // Get the network id
    def networkId = getNetworkID(child)
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    // Get details of the camera device from which the request has come
    def camera = getCameraDetails(networkId, cameraId, child)
    if (!camera) {
        child?.log "Unable to get camera details", "error"
        return false
    }

    def imageURL = camera.thumbnail
    child?.log "Got camera $cameraId -> Image $imageURL", "debug"

    //Now retrieve the image
    def image = queryBlink(imageURL + ".jpg", child)
    //child?.log image.inspect()

    // Now save the image from the device context
    child.saveImage(image)

    return true // all done
}

// Get and update all sensor parameters of camera (Wifi, Signal, Temperature, Battery)
def Boolean updateCameraSensorStatus(child) {
    child?.log "Getting Camera Sensor Status for ${child?.device.displayName}"

    def events = []

    // Get the network id
    def networkId = getNetworkID(child)
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def camera = getCameraDetails(networkId, cameraId, child) // For battery and temperature
    if (!camera) {
        child?.log "Unable to get camera details", "error"
        return false
    }

    def signal = getCameraSignalDetails(networkId, cameraId, child) // For standardized signal levels
    if (!signal) {
        child?.log "Unable to get camera signal details", "error"
        return false
    }

    // Get the camera Battery status
    def battery = camera.battery_level as Float
    child?.log "Got camera $camera.camera_id -> raw battery level $battery"
    battery = (battery / 1.70).round() // Max battery level is 170
    battery = Math.min(battery, 100) // don't let it exceed 100%
    child?.log "Camera $camera.camera_id -> Battery $battery%", "debug"
    events << [name:"battery", value:battery]

    // Get the camera temperature status
    def temperature = camera.temperature
    def unit = "F"
    child?.log "Got camera $camera.camera_id -> Temperature ${temperature} °F", "debug"
    if (location.temperatureScale != "F") { // If it isnt F we need to convert it to C as Blink reports in F
        temperature = (((temperature as Float) - 32) * 5 / 9).round() as Integer // C = (F-32)/9
        unit = "C"
        child?.log "Converted Temperature from °F to °C -> ${temperature} °C", "debug"
    }
    events << [name:"temperature", value:temperature, unit: unit]

    // Get the Camera WiFi signal status
    def wifi = signal.wifi
    child?.log "Got camera $camera.camera_id -> WiFi strength $wifi", "debug"
    events << [name:"wifi", value:wifi]

    // Get the Camera LFR signal status
    def lfr = signal.lfr
    child?.log "Got camera $camera.camera_id -> LFR strength $lfr", "debug"
    events << [name:"lfr", value:lfr]

    // Get last time the sensor data was updated
    def lastUpdate = camera.updated_at
    child?.log "Got camera $camera.camera_id -> Last sensor update $lastUpdate"
    def dateTime = Date.parse("yyyy-MM-dd'T'HH:mm:ssXXX", lastUpdate)
    child?.log "Last sensor update ${dateTime.format("EEE MMM dd yyyy HH:mm z", location.timeZone)}", "debug"
    def strUpdate = dateTime.format("EEE MMM dd", location.timeZone) + "\n " + dateTime.format("HH:mm z", location.timeZone)
    events << [name:"lastUpdate", value:strUpdate]    

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true // all done
}

// Get and update Motion Alerts status of Camera
def Boolean updateCameraMotionAlertsStatus(child) {
    child?.log "Getting Camera Motion Alerts Status for ${child?.device.displayName}"

    def events = []

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    // Get details of the camera device from which the request has come
    def allCameras = getAllCamerasSummary(child) // For camera names and alert status
    if (!allCameras) {
        child?.log "Unable to get all cameras details", "error"
        return false
    }

    // Get the Camera Motion Alerts Status
    def enabled = allCameras.find{it.device_id == (cameraId as Long)}?.enabled
    child?.log "Got camera ${child?.device.displayName} -> Motion Alerts enabled status $enabled", "debug"
    if (enabled) {
        if (child.device.currentValue("motion") == "active") { // If we are currently in an alarm active state
            child?.log "Active Motion Sensor Alert in progress", "debug"
            if (!switchControlsSystem) { // If the switch controls the cameras instead of the system
                events << [name: "alarm", value: "both"]
                events << [name: "switch", value: "on"]
            }
            events << [name: "enableStatus", value: "alarm"]

        } else {
            if (!switchControlsSystem) { // If the switch controls the cameras instead of the system
                events << [name:"alarm", value:"both"]
                events << [name:"switch", value:"on"]
            }
            events << [name:"enableStatus", value:"on"]
        }
    } else {
        if (!switchControlsSystem) { // If the switch controls the cameras instead of the system
            events << [name:"alarm", value:"off"]
            events << [name:"switch", value:"off"]
        }
        events << [name:"enableStatus", value:"off"]
    }

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true // all done
}

// Get the camera configuration and update status
def updateCameraConfig(child) {
    child?.log "Getting Camera Configuration for ${child?.device.displayName}"

    def events = []

    // Get the network id
    def networkId = getNetworkID(child)
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def camera = getCameraConfig(networkId, cameraId, child)
    if (!camera) {
        child?.log "Unable to get camera config details", "error"
        return false
    }

    // Get the camera video recording length
    def length = camera.video_length
    child?.log "Got camera $camera.id -> Video Recording Length $length seconds", "debug"
    events << [name:"videoLength", value:length]
    
    // Get the illuminator LED state
    def led
    switch (camera.illuminator_enable) {
        case 0:
        	led = "off"
            break
            
        case 1:
        	led = "on"
            break
            
        case 2:
        	led = "auto"
            break
            
        default:
            child?.log "Invalid LED State $camera.illuminator_enable", "error"
            led = "off"
            break
    }
    child?.log "Got camera $camera.id -> Illuminator LED State $led", "debug"
    events << [name:"ledStatus", value:led]

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true // all done
}

// Get and update status of Monitoring (Global level)
def Boolean updateMonitorStatus(child) {
    child?.log "Getting Global Monitor Update Status request from ${child?.device.displayName}"

    def monitorStatus
    def alarmSwitch
    def networkInfo = getNetworkInfo(child)
    if (networkInfo?.sync_module_error) {
        child?.log "Global Monitor SYNC MODULE OFFLINE", "warn"
        monitorStatus = "offline"
        alarmSwitch = "off"
    } else if (networkInfo?.armed) {
        child?.log "Global Monitor Armed", "debug"
        monitorStatus = "on"
        alarmSwitch = "on"
    } else {
        child?.log "Global Monitor DisArmed", "debug"
        monitorStatus = "off"
        alarmSwitch = "off"
    }

    // Monitoring is controlled at a global level for all cameras so update all devices
    getChildDevices().each {device ->
        def events = []
        if (switchControlsSystem) { // If the switch controls the system instead of the camera
            events << [name:"alarm", value: alarmSwitch]
            events << [name:"switch", value: alarmSwitch]
        }
        if (monitorStatus == "off") { // If the SM has been turned off, then disable any stuck motion detection notifications
            events << [name: "motion", value: "inactive", descriptionText: "${device.displayName} motion stopped"] // Disable the motion event (if stuck)
            if (device.currentValue("enableStatus") == "alarm") { // Reset the status to on if it's stuck in alarm state
                events << [name: "enableStatus", value: "on"]
            }
        }
        events << [name:"monitorStatus", value: monitorStatus]

        device.generateEvent(events) // Update the device status
    }

    return true
}

// Disable the motion event
def turnOffMotionEvent(child) {
    child?.log "Turning off Camera ${child?.device.displayName} motion events"
    log.trace "Turning off Camera ${child?.device.displayName} motion events"

    def events = []

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    // Get details of the camera device from which the request has come
    def allCameras = getAllCamerasSummary(child) // For camera names and alert status
    if (!allCameras) {
        child?.log "Unable to get all cameras details", "error"
        return false
    }

    // Get the Camera Motion Alerts Status
    def enabled = allCameras.find{it.device_id == (cameraId as Long)}?.enabled
    child?.log "Got camera ${child?.device.displayName} -> Motion Alerts enabled status $enabled", "debug"

    if (enabled) { // If the alerts are active then switch is on and alarm is both
        events << [name: "motion", value: "inactive", descriptionText: "${child?.device.displayName} motion stopped"]
        events << [name: "enableStatus", value: "on"]
    } else { // otherwise all off
        events << [name: "motion", value: "inactive", descriptionText: "${child?.device.displayName} motion stopped"]
        events << [name: "enableStatus", value: "off"]
    }

    // Register all the events with the camera
    child.generateEvent(events) // Update the device status

    return true
}

// Check for any motion events since the last poll
def checkCameraForMotionEvents(allEvents, networkId, child) {
    child?.log "Checking Camera ${child?.device.displayName} for new motion events"
    log.trace "Checking Camera ${child?.device.displayName} for new motion events"

    if (child.device.currentValue("enableStatus") == "off") { // If the camera motion alerts is disabled don't check for motion alerts
        child?.log "Skipping checking Camera ${child?.device.displayName} for new motion events as Camera Motion Alerts is currently disabled"
        log.trace "Skipping checking Camera ${child?.device.displayName} for new motion events as Camera Motion Alerts is currently disabled"
        return true // no motion alerts here
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        log.error "Unable to get camera ID"
        return false
    }

    def events = []

    if (!allEvents) { // Incase we were sent with no events (e.g. sync module list broken), lets get the camera events ourselves
        allEvents = getAllEventsForCamera(networkId, cameraId, child)
        if (!allEvents) {
            child?.log "Unable to get list of all events from camera $cameraId", "error"
            log.error "Unable to get list of all events from camera $cameraId"
        }
    }

    // Filter the motion events for a specific camera given all the events from a sync module
    def motionEvents = allEvents?.findAll { event -> (event.type == "motion") && (event.camera_id == (cameraId as Long)) } // THIS IS IT -> type=motion, created_at=XXX, id=XXX, camera_name=XXX
    //child?.log "Motion Events retrieved for Camera $cameraId:\n${motionEvents?.inspect()}"
    //child?.log "First Motion Event retrieved for Camera $cameraId:\n${motionEvents?.first().inspect()}"
    //child?.log "Last Motion Event retrieved for Camera $cameraId:\n${motionEvents?.last().inspect()}"
    //log.trace "Motion Events retrieved for Camera $cameraId:\n${motionEvents?.inspect()}"
    if (!motionEvents) {
        child?.log "No motion events found for camera ${child?.device.displayName}"
        log.trace "No motion events found for camera ${child?.device.displayName}"
        return true
    }

    // Now check to see if there are any new events since the last time we checked
    child?.log "Found ${motionEvents.size()} motion events for camera ${child?.device.displayName}"
    log.trace "Found ${motionEvents.size()} motion events for camera ${child?.device.displayName}"
    for (motionEvent in motionEvents) {
        def dateTime = Date.parse("yyyy-MM-dd'T'HH:mm:ssXXX", motionEvent.created_at)
        //child?.log "Found motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"
        //log.trace "Found motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"

        if (atomicState."lastMotionCheck${cameraId}") { // Initialize if it hasn't been
            //child?.log "Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
            //log.trace "Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
        } else {
            child?.log "Last time motion event was never checked, initializing last time checked", "warn"
            log.warn "Last time motion event was never checked, initializing last time checked"
            atomicState."lastMotionCheck${cameraId}" = now() // Set the initial reference to check for motion events, use atomicState when using across child/parent interfaces since child cannot update state variables
        }

        if (dateTime > (new Date(atomicState."lastMotionCheck${cameraId}"))) { // Check if this in a new event (since the last time we checked)
            child?.log "Found NEW motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}", "debug"
            log.debug "Found NEW motion event, created at ${dateTime.format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
            events << [name: "motion", value: "active", descriptionText: "${child?.device.displayName} detected a motion event"]
            events << [name: "enableStatus", value: "alarm"]
            child.deferredLoopbackQueue(pollPeriod() * 2, "turnOffMotionEvent", true) // Disable the motion sensor event in 2 x poll period (give it time to process multiple events if there are since we are checking every 60 seconds) (overwrite any existing requests)
            motionDetectedTakeActions(child)
            break // Process only one motion event to avoid multiple reports / conflicts (the camera can generate multiple events in succession)
        }
    }

    // Register all the events with the camera
    events ? child.generateEvent(events) : "" // Update the device status

    atomicState."lastMotionCheck${cameraId}" = now() // Update the last time we checked for new motion events
    //child?.log "UPDATED Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
    //log.trace "UPDATED Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"

    return true // all done
}

// Check if monitor is enabled and if not then enable it
private Boolean checkAndEnableMonitorStatus(child)
{
    // Before you can change motion alerts for a camera, global monitoring must be enabled or Blink will reject the command
    if (child.device.currentValue("monitorStatus") == "off") { // If we are currently in an alarm active state
        child?.log "Global monitoring off, enabling global monitoring before changing camera motion alerts status"
        return monitorOn(child)
    } else {
        return true
    }
}


// OAuth Configuration for Push Camera incoming Web notifications
mappings {
    path("/Blink") {
        action: [
            GET: "cameraCallback",
            POST: "cameraCallback"
        ]
    }
}

// OAuth call back from external REST webservice
def cameraCallback() {
    log.trace "Received event callback Type ${params.type} for Camera Id ${params.camera} with params -> $params"
    
    def type = params.type
    def cameraId = params.camera
    def token = params.access_token
    
    if (token != state.accessToken) { // Make sure we're only receiving requests from the currently active access token
    	log.error "Received event from an inactive client/token. Ignoring"
        return
    }

    if (!cameraId) {
    	log.error "CameraId not specified for callback event, CANNOT proceed"
        return
    }

    def child = getChildDevice(cameraId)
    if(!child) {
        log.error "Received events from UNKNOWN Camera with ID $cameraId"
        return
    }
    
    if (enablePollingEvents) {
        log.warn "Polling enabled, ignoring push motion events"
        return
    }

    if (child.device.currentValue("enableStatus") == "off") { // If the camera motion alerts is disabled don't check for motion alerts
        child?.warn "Ignoring motion event from Camera ${child?.device.displayName} as Camera Motion Alerts is currently disabled"
        log.warn "Ignoring motion event from Camera ${child?.device.displayName} as Camera Motion Alerts is currently disabled"
        return // ignore motion alerts
    }

    switch (type) {
        case "motion": // This is a motion event
            def events = []
        	def dateTime = new Date(now())
            child?.log "Got new motion event at ${dateTime.format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}", "debug"
            log.debug "Got new motion event at ${dateTime.format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
            events << [name: "motion", value: "active", descriptionText: "${child?.device.displayName} detected a motion event"]
            events << [name: "enableStatus", value: "alarm"]
            child.deferredLoopbackQueue(motionOffPeriod(), "turnOffMotionEvent", true) // Disable the motion sensor event in a period (overwrite any existing requests)
            motionDetectedTakeActions(child)

            // Register all the events with the camera
            events ? child.generateEvent(events) : "" // Update the device status

            atomicState."lastMotionCheck${cameraId}" = now() // Update the last time we checked for new motion events incase we revert back to polled events
            //child?.log "UPDATED Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
            //log.trace "UPDATED Last time motion event was checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
            break
            
        default:
            log.error "Unknown event of type $type received from camera $cameraId"
            child?.log "Unknown event of type $type received from camera $cameraId", "error"
        	break
    }
    
    return
}

private setupCallBackURL(child) {
    log.trace "Revoking old and Creating New Access Token for callback" // For security purposes each time we initialize we create a new token
    child?.log "Revoking old and Creating New Access Token for callback" // For security purposes each time we initialize we create a new token
    
    try {
        revokeAccessToken() // First kill the old tokens
        createAccessToken() // Now create a new token
    } catch (e) {
        log.error "Error creating access token, have you ENABLED OAuth in the SmartApp Settings?"
        child?.log "Error creating access token, have you ENABLED OAuth in the SmartApp Settings?", "error"
        log.error "Error : $e"
        child?.log "Error : $e", "error"
        return
    }

    // Each Camera will call this URL with their Id's
    //def callbackURL = "http://graph.api.smartthings.com/api/token/${state.accessToken}/smartapps/installations/${app.id}/Blink"
    //def callbackURL = apiServerUrl("/api/token/${state.accessToken}/smartapps/installations/${app.id}/Blink")
    def callbackURL = apiServerUrl("/api/smartapps/installations/${app.id}/Blink?access_token=${state.accessToken}") // New format per documentation
    
    log.trace "New Blink Callback URL -> $callbackURL"
    child?.log "New Blink Callback URL -> $callbackURL"
    
    return
}

private getCallBackURL(child) {
    if (!state.accessToken) {
        log.error "No Access Token found for callback, no returning any callbackURL"
        child?.log "No Access Token found for callback, no returning any callbackURL", "error"
        return ""
    }
    
    // Each Camera will call this URL with their Id's
    //def callbackURL = "http://graph.api.smartthings.com/api/token/${state.accessToken}/smartapps/installations/${app.id}/Blink"
    //def callbackURL = apiServerUrl("/api/token/${state.accessToken}/smartapps/installations/${app.id}/Blink")
    def callbackURL = apiServerUrl("/api/smartapps/installations/${app.id}/Blink?access_token=${state.accessToken}") // New format per documentation
    
    log.trace "Getting Blink Callback URL -> $callbackURL"
    child?.log "Getting Blink Callback URL -> $callbackURL"
    
    return callbackURL
}



// PARENT CHILD INTERFACES
// Enable live view and get URL
def String getLiveViewURL(child) {
    child?.log "Enable Live View and return URL called by ${child?.device.displayName}"

    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/liveview", child)
    if (ret != null) {
        child?.log "Successfully enabled live view, command Id: $ret.id, URL: $ret.server"

        // If the command was successfully completed then return the URL
        if (getCommandStatus(networkId, ret.id, child)) {
            return ret.server
        } else {
            child?.log "Command not yet completed, live view may not work, try after a while", "warn"
            return ret.server
        }
    } else if (enableRetry) {
        child?.log "Failed to enable live view and get URL, possibly due to busy server. Try again after a while", "error"
        return null
    }

    return null // something went wrong
}

// Turn off Illuminator LED
def Boolean ledOff(child) {
    child?.log "Turn off LED called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/update", child, [illuminator_enable: 0])
    if (ret != null) {
        child?.log "Successfully sent turn off LED, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraConfig(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraConfig") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        child?.log "Failed to send turn off LED possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "ledOff") // If wasnt successful then try again after a while
        sent = false
    }

    return sent
}

// Turn on Illuminator LED
def Boolean ledOn(child) {
    child?.log "Turn on LED called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/update", child, [illuminator_enable: 1])
    if (ret != null) {
        child?.log "Successfully sent turn on LED, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraConfig(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraConfig") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        child?.log "Failed to send turn on LED possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "ledOn") // If wasnt successful then try again after a while
        sent = false
    }

    return sent
}

// Turn Illuminator LED to Auto
def Boolean ledAuto(child) {
    child?.log "Turn LED to Auto called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/update", child, [illuminator_enable: 2])
    if (ret != null) {
        child?.log "Successfully sent turn LED to Auto, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraConfig(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraConfig") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        child?.log "Failed to send turn LED to Auto possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "ledAuto") // If wasnt successful then try again after a while
        sent = false
    }

    return sent
}

// Set the Video Recording Length in Seconds
def Boolean setVideoRecordingLength(child, length) {
    child?.log "Set video recording length to $length, called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/update", child, [video_length: length as Integer])
    if (ret != null) {
        child?.log "Successfully sent set video recording length, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraConfig(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraConfig") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        child?.log "Failed to send Set Video Recording Length possibly due to busy server", "warn"
        updateCameraConfig(child) // We can't reschedule it right now since we can't pass parameters
        sent = false
    }

    return sent
}

// Take a picture with the camera
def Boolean takePicture(child) {
    child?.log "Take picture with camera called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/thumbnail", child)
    if (ret != null) {
        child?.log "Successfully sent Take Picture Request, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            child?.log "Waiting 10 seconds for camera to update Blink servers before getting picture"
            child.deferredLoopbackQueue(10, "updateCameraImage") // If was successful then give it time to complete
        } else {
            child?.log "Command not yet completed, will retry in 15 seconds", "warn"
            child.deferredLoopbackQueue(15, "updateCameraImage") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        child?.log "Failed to send Take Picture Request possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "takePicture") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Enable Camera Motion Alerts
def Boolean enableAlerts(child) {
    child?.log "Enable Camera Motion Alerts called by ${child?.device.displayName}"

    // Santity check before changing alerts
    if (!checkAndEnableMonitorStatus(child)) {
        child?.log "Unable to enable Monitoring", "warn"
    }

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    // Update the last timestamp to check for new events to now (ignore any motion events before now for this camera)
    if (atomicState."lastMotionCheck${cameraId}") { // Initialize if it hasn't been
        //child?.log "Last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"
    } else {
        child?.log "Last time motion event was never checked, initializing last time checked", "warn"
    }

    atomicState."lastMotionCheck${cameraId}" = now() // Set the initial reference to check for motion events
    child?.log "Resetting last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"

    def ret = configureBlink("/network/$networkId/camera/$cameraId/enable", child)
    if (ret != null) {
        child?.log "Successfully sent Enable Camera Motion Alerts, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraMotionAlertsStatus(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraMotionAlertsStatus") // If wasnt successful then give it time to complete
        }

        // Start monitoring for any motion events
        startMonitor(true)
    } else if (enableRetry) {
        child?.log "Failed to send Enable Camera Motion Alerts possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "enableAlerts") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Disable Camera Motion Alerts
def Boolean disableAlerts(child) {
    child?.log "Disable Camera Motion Alerts called by ${child?.device.displayName}"

    // Santity check before changing alerts
    if (!checkAndEnableMonitorStatus(child)) {
        child?.log "Unable to enable Monitoring", "warn"
    }

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/disable", child)
    if (ret != null) {
        child?.log "Successfully sent Disable Camera Motion Alerts, command Id: $ret.id"
        sent = true

        def events = []
        events << [name: "motion", value: "inactive", descriptionText: "${child?.device.displayName} motion stopped"] // Disable the motion event (if stuck)
        child.generateEvent(events) // // Register all the events with the camera

    	// If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateCameraMotionAlertsStatus(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateCameraMotionAlertsStatus") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        child?.log "Failed to send Disable Camera Motion Alerts possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "disableAlerts") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Turn on Monitoring (Globally)
def Boolean monitorOn(child) {
    child?.log "Monitor On called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    // Update the last timestamp to check for new events to now (ignore any motion events before now for this camera)
    if (atomicState."lastMotionCheck${cameraId}") { // Initialize if it hasn't been
        //child?.log "Last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"
    } else {
        child?.log "Last time motion event was never checked, initializing last time checked", "warn"
    }

    atomicState."lastMotionCheck${cameraId}" = now() // Set the initial reference to check for motion events
    child?.log "Resetting last motion event checked at ${new Date(atomicState."lastMotionCheck${cameraId}").format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)} for Camera ${child?.device.displayName}"

    def ret = configureBlink("/network/$networkId/arm", child)
    if (ret != null) {
        child?.log "Successfully sent Monitor Arm, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new monitor status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            updateMonitorStatus(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateMonitorStatus") // If wasnt successful then give it time to complete
        }

        // Start monitoring for any motion events
        startMonitor(true)
    } else if (enableRetry) {
        child?.log "Failed to send Monitor Arm possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "monitorOn") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Turn Monitoring off (global level)
def Boolean monitorOff(child) {
    child?.log "Monitor Off called by ${child?.device.displayName}"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/disarm", child)
    if (ret != null) {
        child?.log "Successfully sent Monitor Disarm, command Id: $ret.id"
        sent = true

        if (getCommandStatus(networkId, ret.id, child)) {
            updateMonitorStatus(child)
        } else {
            child?.log "Command not yet completed, will retry in 5 second", "warn"
            child.deferredLoopbackQueue(5, "updateMonitorStatus") // If wasnt successful then give it time to complete
        }

        // Stop monitoring for any motion events
        stopMonitor()
    } else if (enableRetry) {
        child?.log "Failed to send Monitor Disarm possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "monitorOff") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Force camera to wake up and refresh it's sensor parameters
def Boolean forceCameraSensorUpdate(child) {
    child?.log "Forcing camera ${child?.device.displayName} to wake up and update sensor data"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def ret = configureBlink("/network/$networkId/camera/$cameraId/status", child)
    if (ret != null) {
        child?.log "Successfully sent Camera Refresh Request, command Id: $ret.id"
        sent = true

        // If the command was successfully completed then get the new alerts status otherwise the update
        if (getCommandStatus(networkId, ret.id, child)) {
            child?.log "Waiting 10 seconds for camera to update Blink servers before getting status update"
            child.deferredLoopbackQueue(10, "updateCameraSensorStatus") // If wasnt successful then give it time to complete
        } else {
            child?.log "Command not yet completed, will retry in 15 seconds", "warn"
            child.deferredLoopbackQueue(15, "updateCameraSensorStatus") // If wasnt successful then give it time to complete
        }
    } else if (enableRetry) {
        child?.log "Failed to send Camera Refresh Request possibly due to busy server, retrying in 5 seconds", "warn"
        child.deferredLoopbackQueue(5, "forceCameraSensorUpdate") // If was successful then give it time to complete
        sent = false
    }

    return sent
}

// Refresh all camera parameters
def Boolean refresh(child) {
    child?.log "Refresh called by ${child.device.displayName}"

    //child?.log "Access Token: ${state.accesstoken}", "warn"
    //getActiveSTClients(child) // DEBUG
    //child?.log "Access Token: ${state.accesstoken}", "warn"
    
    def status = updateMonitorStatus(child)
    child?.log "Refresh MonitorStatus: $status"

    status = updateCameraMotionAlertsStatus(child)
    child?.log "Refresh CameraMotionAlertsStatus: $status"

    status = updateCameraSensorStatus(child)
    child?.log "Refresh CameraSensorStatus: $status"

    status = updateCameraImage(child)
    child?.log "Refresh GetImage: $status"
    
    status = updateCameraConfig(child)
    child?.log "Refresh GetCameraConfig: $status"

    if (enablePollingEvents) {
        kickStart() // Kick start the timer if it's dead
    }

    return true // we completed it successfully
}

// Refresh all cameras all parameters
def void refreshAll() {
    getChildDevices().each { device ->
        device?.log "RefreshAll called"
        device.deferredLoopbackQueue(3, "refresh") // Defer the refresh for each device to avoid a timeout while initializing
    }
}

// DEBUGGING INTERFACES
// Send a custom command (for DEBUGGING)
def Boolean customCommandConfigure(cmd, child) {
    child?.log "Custom command configure called by ${child?.device.displayName} with command -> $cmd", "debug"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def command = cmd?.replaceAll(":network", networkId.toString()).replaceAll(":camera", cameraId.toString())
    child?.log "Configuring command -> $command", "debug"
    
    if (!command) {
        child?.log "No command to send", "error"
        return false
    }        

    def ret = configureBlink(command, child)
    if (ret != null) {
        child?.log "Successfully configured Custom Command:\n$ret", "debug"
        sent = true

        // If the command was successfully completed
        if (getCommandStatus(networkId, ret.id, child)) {
            child?.log "Command was sent successfully", "debug"
        } else {
            child?.log "Command not yet completed", "warn"
        }
    } else if (enableRetry) {
        child?.log "Failed to configure custom command", "error"
        sent = false
    }

    return sent
}

// Get a custom command (for DEBUGGING)
def Boolean customCommandQuery(cmd, child) {
    child?.log "Custom command query called by ${child?.device.displayName} with command -> $cmd", "debug"

    def sent = false
    def networkId = isSyncModuleOnlineGetID(child) // Check if sync module is online (and update status) before sending any configuration commands
    if (!networkId) {
        child?.log "Unable to get networkID", "error"
        return false
    }

    def cameraId = child?.device.deviceNetworkId
    if (!cameraId) {
        child?.log "Unable to get camera ID", "error"
        return false
    }

    def command = cmd?.replaceAll(":network", networkId.toString()).replaceAll(":camera", cameraId.toString())
    child?.log "Querying command -> $command", "debug"
    
    if (!command) {
        child?.log "No command to query", "error"
        return false
    }        

    def ret = queryBlink(command, child)
    if (ret != null) {
        child?.log "Successfully queried Custom Command, response:\n$ret", "debug"
        sent = true
    } else if (enableRetry) {
        child?.log "Failed to query custom command", "error"
        sent = false
    }

    return sent
}